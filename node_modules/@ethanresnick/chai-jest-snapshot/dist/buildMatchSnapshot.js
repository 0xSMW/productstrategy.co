'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _jsonpath = require('jsonpath');

var _jsonpath2 = _interopRequireDefault(_jsonpath);

var _lodash = require('lodash.values');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.clonedeep');

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require('lodash.clone');

var _lodash6 = _interopRequireDefault(_lodash5);

var _lodash7 = require('lodash.set');

var _lodash8 = _interopRequireDefault(_lodash7);

var _jestSnapshot = require('jest-snapshot');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var buildMatchSnapshot = function buildMatchSnapshot(utils, parseArgs) {
  if (thisRunsInJest()) {
    var jestExpect = safeRequireJestExpect();
    if (jestExpect) {
      return function matchSnapshot() {
        var _jestExpect;

        return (_jestExpect = jestExpect(this._obj)).toMatchSnapshot.apply(_jestExpect, arguments);
      };
    }
  }

  return function matchSnapshot() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // support passing a property matcher object as first argument.
    // This is backwards compatible, as all the prior args were strings or bools.
    var propertyMatchers = _typeof(args[0]) === 'object' ? args.shift() : void 0;

    var _parseArgs = parseArgs(args),
        snapshotFilename = _parseArgs.snapshotFilename,
        snapshotName = _parseArgs.snapshotName,
        update = _parseArgs.update,
        ci = _parseArgs.ci;

    if (utils.flag(this, 'negate')) {
      throw new Error("`matchSnapshot` cannot be used with `.not`.");
    }

    var obj = this._obj;
    var absolutePathToSnapshot = _path2.default.resolve(snapshotFilename);
    var snapshotState = new _jestSnapshot.SnapshotState(absolutePathToSnapshot, {
      updateSnapshot: ci ? 'none' : update ? 'all' : 'new'
    });

    // Treat property matchers as jsonpath queries
    // if they start with a $ and contain a dot.
    var isJsonPath = function isJsonPath(it) {
      return it[0] === '$' && it.indexOf(".") > -1;
    };

    // If we have property matchers, we have to reassign the value (pattern)
    // from the matcher into the data being snapshotted, so that that data
    // _with the matcher applied_ gets compared to the existing snapshot.
    // We don't want to mutate the user's data, though, so we have to clone.
    // And, if some of our matchers are jsonpath matchers, though, we have to
    // do a deep clone, because the jsonpath could match a deep property.
    var toMatch = function () {
      // No matchers == no cloning required
      if ((typeof propertyMatchers === 'undefined' ? 'undefined' : _typeof(propertyMatchers)) !== 'object') {
        return obj;
      }

      var hasJsonPathMatchers = Object.keys(propertyMatchers).some(isJsonPath);
      return hasJsonPathMatchers ? (0, _lodash4.default)(obj) : (0, _lodash6.default)(obj);
    }();

    if ((typeof propertyMatchers === 'undefined' ? 'undefined' : _typeof(propertyMatchers)) === 'object') {
      Object.keys(propertyMatchers).forEach(function (k) {
        if (isJsonPath(k)) {
          _jsonpath2.default.paths(obj, k).forEach(function (path) {
            var lodashPath = path.slice(1);
            (0, _lodash8.default)(toMatch, lodashPath, propertyMatchers[k]);
          });
        } else {
          toMatch[k] = propertyMatchers[k];
        }
      });
    }

    // If some custom serializers apply to our original data to snapshot,
    // the cloning that we do to apply property matchers could break the
    // custom serializer (e.g., by removing unenumerable properties from the
    // data that the custom serializer is relying on). If we're in such a case,
    // we log a warning.
    //
    // Note: we only test the top-level data for cusotm serializers
    // (jest might look for them recursively).
    var logCustomSerializerWarning = obj !== toMatch // we cloned
    && (0, _jestSnapshot.getSerializers)().some(function (it) {
      return it.test(obj);
    }); // has custom serializers

    if (logCustomSerializerWarning) {
      console.warn("Using property matchers may change how your object is serialized for snapshotting.");
    }

    var match = snapshotState.match({
      testName: snapshotName,
      received: toMatch,
      key: snapshotName
    });

    var actual = match.actual || "";
    var expected = match.expected || "";
    snapshotState.save();

    this.assert(match.pass, 'expected value to match snapshot ' + snapshotName, 'expected value to not match snapshot ' + snapshotName, expected.trim(), actual.trim(), true);
  };
};

var safeRequireJestExpect = function safeRequireJestExpect() {
  // Jest might rename its "jest-matchers" module to "expect", so let's
  // avoid an actual require and bank on the global expect here.
  // (see https://github.com/facebook/jest/issues/1679#issuecomment-282478002)
  return typeof expect === 'undefined' ? null : expect;
};

var JEST_MARKERS = ["enableAutomock", "genMockFromModule", "clearAllMocks", "runAllTicks"];

var thisRunsInJest = function thisRunsInJest() {
  return (typeof jest === 'undefined' ? 'undefined' : _typeof(jest)) === "object" && JEST_MARKERS.every(function (marker) {
    return typeof jest[marker] === "function";
  });
};

exports.default = buildMatchSnapshot;